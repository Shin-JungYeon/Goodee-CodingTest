package week2;

import java.util.*;

// 그리디(최적의 조건을 찾아서 풀기)
//[백준 1946번] 신입사원 문제

/* 문제 요약
: 사람 수 그리고 각각의 서류심사순위와 면접시험순위를 받아와서 모든 사람과 비교했을 때 
    서류와 면접 심사순위 모두 다른 사람 보다 낮은경우엔 채용에 선발되지 않는다.  
    만약, 둘 중 한 심사 순위만 낮은 경우엔 채용된다.
*/

/* 문제 접근
- 서류심사순위와 면접시험순위를 이차원 배열에 저장한 후 값을 비교.
- 순서는 중요하지 않기 때문에 Arrays메소드를 이용하여 서류심사 순위로 정렬
- 서류심사순위로 정렬했을 때 면접시험 순위가 내 앞사람보다 잘 봤을 경우에  채용확정이므로 cnt의 숫자를 늘려줌.
(가장 작은 면접시험 순위를 min값에 저장하여 그 숫자보다 더 작은 숫자를 가지고 있을 경우에만 cnt를 늘려주는 방식)
*/
public class N_1946 {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int caseN = scan.nextInt(); // 테스트 케이스를 받아오는 변수 생성
		for(int i=0; i<caseN; i++) { // 테스트 케이스만큼 실행시킴
			// 다음 테스트케이스를 위해 cnt,min,arr값 초기화.
			int cnt = 0; // 채용인원을 저장할 변수.
			int min = 999999; // 면접시험의 가장 낮은 순위를 저장할 변수. 
			
			/* Q: 왜 최소값을 999,999로 저장했나요?
			 * A: 최대 100,000명의 지원자가 있으므로 
			 *    순위를 저장하는 min변수는 더 큰 숫자로 초기화 시켜줘야하기 때문입니다!
			 *    사실 100,000보다만 큰 값을 넣어주면 아무 값이나 상관없습니다~ 
			 */
			
			int n = scan.nextInt(); // 사람 수를 받아오는 변수.
			int[][] arr = new int[n][2]; // 사람 수 만큼 서류심사순위[0]와 면접시험순위[1]저장.
			
			for(int j=0; j<n; j++) {
				// 각각 배열에 순위 저장
				arr[j][0] = scan.nextInt(); // 서류심사순위
				arr[j][1] = scan.nextInt(); // 면접시험순위
				
			}
			
			// 이차원 배열에서 서류심사순위를 기준으로 정렬 (오름차순)
			// 정렬하는 이유는 둘 중에 하나의 성적만 높으면 되기때문에 (동석차 X)
			// 일단 서류심사순위로 정렬하여 비교하는 범위를 더 줄위기 위함입니다!
			Arrays.sort(arr, (o1, o2) -> {return o1[0] - o2[0];});
			
			/* 위 코드는 아래 코드를 조금 더 쉽고 간단하게 표시한 방식입니다. 간결한 표시 방식을 알아둡시다~
			 * 0번째 열을 기준으로 정렬하는 코드입니다!
			  	Arrays.sort(arr, new Comparator<int[]>() {
		            @Override
		            public int compare(int[] o1, int[] o2) {
		                return o1[0] - o2[0];
		                // 내림자순 정렬을 하고 싶다면 o2와 o1의 위치를 바꿔줍니다
		                // return o2[1] - o1[1];
		            }
	        	});
			 */
			
			for(int a=0; a<n; a++) {
				// 서류심사순위가 앞사람보다는 뒷쳐지지만 면접시험순위가 더 좋은 경우(숫자가 작은경우) 채용
				if(min > arr[a][1]) { 
					cnt++; // 채용인원 증가
					min = arr[a][1]; // 계속 작은 순위 값을 저장시켜야 제대로 된 비교가 가능합니다!
				}
			}
			System.out.println(cnt);
		}
	}
}
